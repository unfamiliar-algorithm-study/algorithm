/**
 * 
 */
package linkedlist;

import javax.xml.stream.events.NotationDeclaration;

/**
 * @author yenos
 * @date 2016. 9. 4.
 */
public class LinkedList {

	class Node {
		String data;
		Node next;
	}

	private Node head = null;
	private Node lastNode = new Node();

	public LinkedList() {

	}
	
	public void middleAdd(int index,String data){
		
	}
	
	public void addFirst(String data) {
		Node tmp = new Node();
		tmp.data = data;

		// 원래 헤드가 가리치고있는애를 임시변수가 가리치고 있어야 한다.
		tmp.next = head.next;
		// 그리고 해드의 다음은 tmp가 되어야한다.
		head.next = tmp;
	}

	// last add
	public void addLast(String data) {
		Node tmp = new Node();
		tmp.data = data;

		if (head == null) {
			head = new Node();
			// 해드의 노등가 이노드를 가지고있는다.
			head.next = tmp;
			// 라스트는 tmp자체가 되고
			lastNode = tmp;

		} else {
			// 현재의 라스트는?
			// 혀재라스트의 다음을 tmp로 넣어주
			lastNode.next = tmp;

			// 라스트는 다시 tmp로 설정한다.
			lastNode = tmp;
		}
	}

	public String getLastData() {
		return lastNode.data;
	}

	public void showAllNode() {
		System.out.println("==== show all Linked list ====");

		Node tmp = new Node();
		tmp = head;

		while (tmp != lastNode) {
			// 새로운노드 추가.
			Node a = new Node();
			if (tmp != null) {
				// 탬프의 넥스트를 a가 가지
				a = tmp.next;
				// tmp는 다시 a의 next를 가진다.
				tmp = a;
				System.out.println(a.data);
			} else {
				break;
			}
		}
		System.out.println("==== end ====");

	}
	
	public String searchWithIndex(int index){
		Node tmp = new Node();
		tmp = head;

		int i = 0;
		
		while (tmp != lastNode) {
			
			// 새로운노드 추가.
			Node a = new Node();
			if (tmp != null) {
				// 탬프의 넥스트를 a가 가지
				a = tmp.next;
				// tmp는 다시 a의 next를 가진다.
				tmp = a;
				if(i==index){

					return a.data;
				}
				i++;
			} else {
				return null;
			}
		}
		return null;
	}
	
	public int searchWithData(String data){
		Node tmp = new Node();
		tmp = head;

		int i = 0;
		
		while (tmp != lastNode) {
			
			// 새로운노드 추가.
			Node a = new Node();
			if (tmp != null) {
				// 탬프의 넥스트를 a가 가지
				a = tmp.next;
				// tmp는 다시 a의 next를 가진다.
				tmp = a;
				if(a.data.equals(data)){
					return i;
				}
				i++;
			} else {
				//탈출하는부분. 즉 매칭값이 없으면 null을 호출한다.
				return 0;
			}
		}
		
		return 0;
	}
	
	private Node searchWithIndex(int index){
		Node tmp = new Node();
		tmp = head;

		int i = 0;
		
		while (tmp != lastNode) {
			
			// 새로운노드 추가.
			Node a = new Node();
			if (tmp != null) {
				// 탬프의 넥스트를 a가 가지
				a = tmp.next;
				// tmp는 다시 a의 next를 가진다.
				tmp = a;
				if(i==index){

					return a;
				}
				i++;
			} else {
				return null;
			}
		}
		return null;
	}

}
