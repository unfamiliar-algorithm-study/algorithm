/**
 * 
 */
package tree;

/**
 * @author yenos
 * @date 2016. 9. 14.
 */
public class binarySearch {
	public class Node {
		int data;
		Node left;
		Node right;
	}

	Node startNode;

	public void insertNode(int data) {
		if (startNode == null) {
			Node node = new Node();
			node.data = data;

			startNode = node; // 최초 시작 시 노드의 값이 없을수있음으로.
		} else {
			// root가 존재할 경우다음데이터를 넣어준다.
			insertNode(data, startNode);
		}
	}

	public void insertNode(int data, Node node) {

		// 노드에 따라 달라질경우.
		// 데이터를 비
		if (data <= node.data) {
			// 들어갈 데이터가 작으면 왼쪽으로 이동 널이면 새로운것을 넣어주면 되는것이고, 널이 아니 해당노드로 다시 탐색에
			// 들어가면된다.
			if (node.left == null) {
				Node newNode = new Node();
				newNode.data = data;
				node.left = newNode;
			} else {
				insertNode(data, node.left);
			}
		} else {
			if (node.right == null) {
				Node newNode = new Node();
				newNode.data = data;
				node.right = newNode;
			} else {
				insertNode(data, node.right);
			}
		}
	}

	// 전위순위알고리즘
	// DLR
	public void preOrder(Node node) {
		if (node == null) {
		} else {
			System.out.print(node.data + "=>");
			preOrder(node.left);
			preOrder(node.right);
		}

	}

	// 중위순위알고리즘
	// LDR
	public void inOrder(Node node) {
		if (node == null) {
		} else {

			inOrder(node.left);
			System.out.print(node.data + "=>");
			inOrder(node.right);
		}
	}
	// 후위순위 알고리즘
	// LRD

	public void postOrder(Node node) {
		if (node == null) {

		} else {

			postOrder(node.left);
			postOrder(node.right);

			System.out.print(node.data + "=>");
		}
	}

	public void remove(int data) {

	}

	
	Node selectedNode ;
	public void searchNode(int data, Node node) {

		if (data <= node.data) {
			if (node.left == null) {
				
				selectedNode = node;
				
			} else {
				insertNode(data, node.left);
			}
		} else {
			if (node.right == null) {

				selectedNode = node;
			} else {
				insertNode(data, node.right);
			}
		}
	}

	// public void insertData(int x) {
	//
	// //받아온데이터로 새로운 노드를 만들어준다.
	// Node newNode = new Node();
	// newNode.data = x;
	// newNode.left = null;
	// newNode.right = null;
	//
	// //시작노드를찾는다. 없다면 새로만들어준 녀석이 새로운 시작노드가 될것이다.
	// if(startNode==null){
	// startNode = newNode;
	// //시작노드가 새노드가 아닐경우.
	// // 탐색 => 알맞은 위치 찾기 => 데이타 사이즈를 보고 왼쪽혹은 오른쪽에 넣어둔다.
	// }else{
	//
	// //탐색
	// //스타트노드의 키값으로 왼쪽으로 갈지 오른쪽으로 갈지를 정한다.
	//
	//
	//
	// Node tmp ;
	//
	// //스타트 데이터와의 비교롤 통해 다음 노드를 결정한다.
	// tmp = startNode.data < x ? startNode.right: startNode.left;
	// // 둘다 널이면 갈떄 까지 간거다
	// if(tmp.left==null & tmp.right==null){
	// if(tmp.data<x){
	// tmp.right = newNode;
	// }else if(tmp.data>x){
	// tmp.left = newNode;
	// }else{
	// System.out.println("already has a Data");
	// }
	// //둘다 널이 아닐경우 아닌쪽을 찾아간다.
	// }else{
	// if(tmp.data<x){
	// if(tmp.right==null){
	// tmp.right = newNode;
	// }else{
	// tmp =tmp.right ;
	// }
	//
	// }else if(tmp.data>x){
	// if(tmp.left==null){
	// tmp.left= newNode;
	// }else{
	// tmp = tmp.left;
	// }
	//
	// }else{
	// System.out.println("already has a Data");
	// }
	// }
	//
	//
	//
	// }
	//
	// }

}
